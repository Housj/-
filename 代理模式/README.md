代理模式（Proxy Pattern）
    一个类代表另一个类的功能。这种类型的设计模式属于结构型模式。

定义：
    为其他对象提供一种代理以控制对这个对象的访问。在某些情况下，一个对象不适合或者不能直接引用另一个对象，
    而代理对象可以在客户端和目标对象之间起到中介的作用

角色：
    1，抽象角色：声明真实对象和代理对象的共同接口。
    2，代理角色：代理对象角色内部含有对真实对象的引用，从而可以操作真实对象，同时代理对象提供与真实对象相同的接口以便在任何时刻都能代替真实对象。
               同时，代理对象可以在执行真实对象操作时，附加其他的操作，相当于对真实对象进行封装。
    3，真实角色：代理角色所代表的真实对象，是我们最终要引用的对象。

分类：
静态代理
    静态代理也就是在程序运行前就已经存在代理类的字节码文件，代理类和委托类的关系在运行前就确定了。
    
动态代理
    动态代理类的源码是程序在运行期间由JVM根据反射等机制动态生成的，所以不存在代理类的字节码文件。代理角色和真实角色的联系在程序运行时确定。
JDK 自带的动态代理
 java.lang.reflect.Proxy:生成动态代理类和对象；
 java.lang.reflect.InvocationHandler（处理器接口）：可以通过invoke方法实现
 
Cglib 动态代理是针对代理的类, 动态生成一个子类, 然后子类覆盖代理类中的方法, 如果是private或是final类修饰的方法,则不会被重写。
CGLIB是一个功能强大，高性能的代码生成包。它为没有实现接口的类提供代理，为JDK的动态代理提供了很好的补充。通常可以使用Java的动态代理创建代理，但当要代理的类没有实现接口或者为了更好的性能，CGLIB是一个好的选择。
CGLIB作为一个开源项目，其代码托管在github，地址为：https://github.com/cglib/cglib
    
优点：
   业务类只需要关注业务逻辑本身，保证了业务类的重用性。这是代理的共有优点。 
   能够协调调用者和被调用者，在一定程度上降低了系统的耦合度。

缺点：
   由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢，例如保护代理。

实现代理模式需要额外的工作，而且有些代理模式的实现过程较为复杂，例如远程代理。